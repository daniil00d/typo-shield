## А что здесь будем писать и как это будет работать

### Лексический анализатор
- Берем строку как константу, разбиваем ее на лексемы
- упор делаем больше на директиву @serve и все, что ее окружает
- все те же методы для утилитарных директив (#include & #exclude)
- На выходе должны получить некоторый объект с методами (из директивы @serve) и ее окр параметрами

## На втором этапе нужно получить некоторые ограничения для регистрации имплементации эндпоинта

```ts
app.registerImplementation('GetUser', ({body, search}, {req, res}) => {return {}})
//                            ^ здесь мы должны ограничить названия методов, и тем
//                              самым подсказать правильное название

/* ----------------------------------------------------------------------------- */ 

app.registerImplementation('GetUser', ({body, search}, {req, res}) => {return {}})
//                                           ^ здесь мы должны предоставить параметры из директив,
//                                             которые описаны около директивы @serve

/* ----------------------------------------------------------------------------- */ 

app.registerImplementation('GetUser', ({body, search}, {req, res}) => {return {}})
//                                                          ^ здесь мы должны предоставить res & req & next 
//                                                            от дефолтной ручки Express

// регистрация одиночного метода
app.registerImplementation(name: string, (epParams, expressParams) => output: epOutput)

// регистрация списка методов
app.registerImplementations([...{name, methodCallback}[]])
```

### Общий пайплайн типов:

